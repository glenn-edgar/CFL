#ifndef __assert_column_H__
#define __assert_column_H__

#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h>   


#include "run_time_code_CFL.h"
#include "CFL_column_element_state_utilities.h"


//nuser defined events 



//----------RAM data structures for event queues ----

static Event_control_RAM_CFL_t xjsddktlpr[8];
static Event_data_CFL_t xsxybxpxhd[7];
static Event_data_CFL_t agjzaczkme[0];
static Event_data_CFL_t tgzljndlro[0];
static Event_data_CFL_t kwgkvpyscn[0];
static Event_data_CFL_t ansjvazixa[0];
static Event_data_CFL_t fetpmkypra[0];
static Event_data_CFL_t vftkwyudvk[0];
static Event_data_CFL_t jnfstkswwf[0];


//------  ROM data structures for event queues ----

static const Event_control_ROM_CFL_t ybgzoydkrq[] = { 
     {  7, xsxybxpxhd },
     {  0, agjzaczkme },
     {  0, tgzljndlro },
     {  0, kwgkvpyscn },
     {  0, ansjvazixa },
     {  0, fetpmkypra },
     {  0, vftkwyudvk },
     {  0, jnfstkswwf },
};
static const Log_message_CFL_t zuteeatvpo = { "assert_time_delay", false, NULL };
static const unsigned short spgvrkhgxo[] = { 1,2,3};
const Enable_column_CFL_t pidwixlhuo = { true, 3, spgvrkhgxo };


unsigned  sdenehebkx;
const While_time_control_ROM_CFL_t dhxpenbeeg = { 20000,&sdenehebkx };



static While_control_RAM_CFL_t qjyqgprrni_ram = { 0 };  // current count 


  

static const While_control_ROM_CFL_t dhzmnzstes_rom = { 0 ,true, (void*)&dhxpenbeeg,&qjyqgprrni_ram,null_function};

    
static const Log_message_CFL_t vytjfdleeo = { "assert_time_delay is terminating", false, NULL };
static const Log_message_CFL_t dzpcwspqwh = { "assert_reset", false, NULL };
static const unsigned short jqlnzykzmw[] = { 4,5,6};
unsigned short bfqxcsxbig = 0;
bool ubytklaqqo = true;
const sequence_columns_CFL_t ulumvdkkfs = { 3, jqlnzykzmw, &bfqxcsxbig, &ubytklaqqo };
bool rqjjqdamhf = true;
const Assert_column_CFL_t tkxxlztgag = { ulumvdkkfs, NULL, false, &rqjjqdamhf };
static const Log_message_CFL_t micoiidgzl = { "assert_reset_pass is terminating", false, NULL };
static const Log_message_CFL_t rjotiiecqh = { "assert_reset", false, NULL };


unsigned  dgsvpedljb;
const While_time_control_ROM_CFL_t npknduwrro = { 4500,&dgsvpedljb };



static While_control_RAM_CFL_t lwtfnbihza_ram = { 0 };  // current count 


  

static const While_control_ROM_CFL_t zhvljaasbd_rom = { 0 ,true, (void*)&npknduwrro,&lwtfnbihza_ram,null_function};

    
static const unsigned short ogxtpyeqiq[] = { 4,5,6};
unsigned short qmdlpfpxxb = 0;
bool rekjahuign = true;
const sequence_columns_CFL_t kovszxvsxl = { 3, ogxtpyeqiq, &qmdlpfpxxb, &rekjahuign };
bool ykgzozovzv = true;
const Assert_column_CFL_t pmrxqnulof = { kovszxvsxl, NULL, false, &ykgzozovzv };
static const Log_message_CFL_t xrbluqsccx = { "assert_reset_fail is terminating", false, NULL };


unsigned  sweynnrkrx;
const While_time_control_ROM_CFL_t gschzmtzhe = { 4000,&sweynnrkrx };



static While_control_RAM_CFL_t udmltztyih_ram = { 0 };  // current count 


  

static const While_control_ROM_CFL_t vtgykebmlx_rom = { 0 ,true, (void*)&gschzmtzhe,&udmltztyih_ram,null_function};

    
static const Log_message_CFL_t fciwyquwrg = { "assert_termination", false, NULL };
static const unsigned short hjjhgeqvbt[] = { 4,5,6};
unsigned short ptsyqqhlrx = 0;
bool evmyqohkhi = true;
const sequence_columns_CFL_t vfeprslfhq = { 3, hjjhgeqvbt, &ptsyqqhlrx, &evmyqohkhi };
bool xgdcbtrxbw = true;
const Assert_column_CFL_t tnuywmgrrx = { vfeprslfhq, NULL, true, &xgdcbtrxbw };
static const Log_message_CFL_t skrjmyzrhy = { "assert_termination is terminating", false, NULL };
static const Log_message_CFL_t uovlqgaibh = { "error_column_1 is active", false, NULL };


unsigned  xnxsmtyaah;
const While_time_control_ROM_CFL_t hdcatbgpgw = { 100,&xnxsmtyaah };



static While_control_RAM_CFL_t hjcgiyxusm_ram = { 0 };  // current count 


  

static const While_control_ROM_CFL_t fqbkspsama_rom = { 0 ,true, (void*)&hdcatbgpgw,&hjcgiyxusm_ram,null_function};

    
static const Log_message_CFL_t puoxuxuhcc = { "error_column_1 is terminating", false, NULL };
static const Log_message_CFL_t yekjdkqxri = { "error_column_2 is active", false, NULL };


unsigned  gpcjzkgeah;
const While_time_control_ROM_CFL_t xlmkojqqup = { 100,&gpcjzkgeah };



static While_control_RAM_CFL_t dfhqlijtsy_ram = { 0 };  // current count 


  

static const While_control_ROM_CFL_t btvwldvdjg_rom = { 0 ,true, (void*)&xlmkojqqup,&dfhqlijtsy_ram,null_function};

    
static const Log_message_CFL_t vzwmbzwpjr = { "error_column_2 is terminating", false, NULL };
static const Log_message_CFL_t ztuttxdkwe = { "error_column_3 is active", false, NULL };


unsigned  jrybtgrong;
const While_time_control_ROM_CFL_t bhoblhjase = { 100,&jrybtgrong };



static While_control_RAM_CFL_t xddttogtqe_ram = { 0 };  // current count 


  

static const While_control_ROM_CFL_t wjvgbmozjy_rom = { 0 ,true, (void*)&bhoblhjase,&xddttogtqe_ram,null_function};

    
static const Log_message_CFL_t uawhikqwuw = { "error_column_3 is terminating", false, NULL };


//----------RAM data structures for columns ----

unsigned cigivlywza[7];
Watch_dog_struct_CFL_t * kjogtouike[7];
unsigned char teyszyvvrt[7];
unsigned char qjzgqidtnn[7];
void* athjunopto[7];


//----------ROM data structures for columns ----

static const Column_ROM_CFL_t rjkoperkkl[] = {
  { 1,true, 0, 5, 0, -1, -1,NULL },
  { 2,false, 1, 3, 5, -1, -1,NULL },
  { 3,false, 2, 4, 8, -1, -1,NULL },
  { 4,false, 3, 4, 12, -1, -1,NULL },
  { 5,false, 4, 4, 16, -1, -1,NULL },
  { 6,false, 5, 4, 20, -1, -1,NULL },
  { 7,false, 6, 4, 24, -1, -1,NULL },
};


//----------Column elements RAM structures----



static unsigned char quiqxplxzv[28];


  /* 
  ------------------------ Column element Flash structure --------------------------
     typedef struct Column_element_CFL_t {
        Column_function_CFL_t column_function;
        void *aux_fn;
        void *params
     } Column_element_CFL_t;

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

*/

  

//----------Column elements Flash structures----

static const Column_element_CFL_t zruaoepkku[] = {
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&zuteeatvpo}, // 0 
    {bidirectional_one_shot_handler_CFL,enable_columns_function_CFL,(void *)&pidwixlhuo}, // 1 
    {while_handler_CFL,wait_time_delay_CFL,(void *)&dhzmnzstes_rom}, // 2 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&vytjfdleeo}, // 3 
    {return_condition_code_CFL,NULL,(void *)terminate_buffer}, // 4 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&dzpcwspqwh}, // 5 
    {assert_column_CFL,true_constant_handler,(void *)&tkxxlztgag}, // 6 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&micoiidgzl}, // 7 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&rjotiiecqh}, // 8 
    {while_handler_CFL,wait_time_delay_CFL,(void *)&zhvljaasbd_rom}, // 9 
    {assert_column_CFL,false_constant_handler,(void *)&pmrxqnulof}, // 10 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&xrbluqsccx}, // 11 
    {while_handler_CFL,wait_time_delay_CFL,(void *)&vtgykebmlx_rom}, // 12 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&fciwyquwrg}, // 13 
    {assert_column_CFL,false_constant_handler,(void *)&tnuywmgrrx}, // 14 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&skrjmyzrhy}, // 15 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&uovlqgaibh}, // 16 
    {while_handler_CFL,wait_time_delay_CFL,(void *)&fqbkspsama_rom}, // 17 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&puoxuxuhcc}, // 18 
    {return_condition_code_CFL,NULL,(void *)terminate_buffer}, // 19 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&yekjdkqxri}, // 20 
    {while_handler_CFL,wait_time_delay_CFL,(void *)&btvwldvdjg_rom}, // 21 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&vzwmbzwpjr}, // 22 
    {return_condition_code_CFL,NULL,(void *)terminate_buffer}, // 23 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&ztuttxdkwe}, // 24 
    {while_handler_CFL,wait_time_delay_CFL,(void *)&wjvgbmozjy_rom}, // 25 
    {bidirectional_one_shot_handler_CFL,log_message_CFL,(void *)&uawhikqwuw}, // 26 
    {return_condition_code_CFL,NULL,(void *)terminate_buffer}, // 27 
};
Bitmap_CFL ovgqxmsycs[0];
Registermap_CFL_t grdlgowygt[0];
Floatmap_CFL_t nhrzeametq[0];
const Sm_control_ROM_CFL_t zsnehsynez[0];
Sm_control_RAM_CFL_t zvqjfksxml[0];


static Time_control_CFL_t xxaxyezukn;




static Engine_control_CFL_t duzrlhypkz;


/* remaining allocate heap size */

static unsigned erankcgomt;


/* current heap pointer */

static char* pluvpcmaqt;


/* heap block area */

static CS_MEMORY_CONTROL doczigkxtp;


    
    


const struct Handle_CFL_t hhhpdjervl =
{

  .queue_number = 8,
  .queue_rom = ybgzoydkrq,
  .queue_ram = xjsddktlpr,

  .column_elements_flags =quiqxplxzv,
  .column_elements_ROM = zruaoepkku,

  .watch_dog_struct = kjogtouike,
  .watch_dog_count  = cigivlywza,
   
   
  .column_flags = teyszyvvrt,
  .column_local_data = athjunopto,
  .column_state = qjzgqidtnn,
  .number_of_columns = 7,
  .column_rom_data = rjkoperkkl,

  
  
  
  .time_control = &xxaxyezukn,
  .engine_control =&duzrlhypkz,
  .debug_function = debug_write,
  .malloc = private_heap_malloc_CFL,
  .free = private_heap_free_CFL,
  .allocate_once = allocate_once_CFL,
  .master_heap_starting_location = &allocate_once_memory,
  .master_heap_size = 2000,
  .remaining_heap_size = &erankcgomt,
  .current_heap_location = &pluvpcmaqt,
  .private_heap   = &doczigkxtp,
  .private_heap_size =   1000,
  .number_of_sm      = 0,
  .sm_rom     =  zsnehsynez,
  .sm_ram     = zvqjfksxml,
  .number_of_bitmaps = 0,
  .bitmaps = ovgqxmsycs,
  .number_of_registermaps = 0,
  .registermaps = grdlgowygt,
  .number_of_floatmaps = 0,
  .floatmaps = nhrzeametq,
} ;

const Handle_CFL_t*  assert_column_handle(){
    return &hhhpdjervl;
}
   

#ifdef __cplusplus
}
#endif

#endif
