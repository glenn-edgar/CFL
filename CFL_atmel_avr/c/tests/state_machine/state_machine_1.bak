
set_h_file("state_machine.h")

local entry_point = "state_machine_handle"

local allocate_once_heap_size = 2000
local private_heap_size = 1000
local default_event_queue_size = 10 
start_build(entry_point,"allocate_once_memory",allocate_once_heap_size,private_heap_size,default_event_queue_size,'debug_write')


Define_state_machine(sm_column_list)
Define)sm
Define_state()
End_state_machine)
Change_state(sm_name,state_name)

Define_state_machine("sm_array_name",{"test_sm"})

     Def_columns("test_sm_column_array",{"test_sm_manager_chain","test_sm_test_state1_chain","test_sm_test_state2_chain","test_sm_test_state3_chain"})

     Define_event_queue("test_sm_queue",10)

     Define_event_queue("test_sm_test_state1_queue",10)

     Define_event_queue("test_sm_test_state2_queue",10)

     Define_event_queue("test_sm_test_state3_queue",10)

     Define_sm("test_sm",{"test_state1","test_state2","test_state3"},"test_sm_manager_chain","test_sm_queue","test_state1","(void *)test_data")

       Define_state("test_state1","test_sm_test_state1_chain","test_sm_test_state1_queue")

       Define_state("test_state2","test_sm_test_state2_chain","test_sm_test_state2_queue")

       Define_state("test_state3","test_sm_test_state3_chain","test_sm_test_state3_queue")

     End_state_machine()




     Start_queue_column("test_sm_manager_chain",false,"test_sm_queue")
        Log_msg('state machine manager starting')
        Halt_column()
     End_column()




     Start_queue_column("test_sm_test_state1_chain",false,"test_sm_test_state1_queue")
        Log_msg('test_state1 starting')
        Set_sm_user_data('test_sm','(void *)state1_data')
        One_shot('DISPLAY_SM_USER_DATA','NULL')
        Wait_delay(1000)
        Log_msg('changing state to test_state2')
        Change_state('test_sm','test_state2')
        Halt_column()
     End_column()




     Start_queue_column("test_sm_test_state2_chain",false,"test_sm_test_state2_queue")
        Log_msg('test_state2 starting')
        Set_sm_user_data('test_sm','(void *)state2_data')
        One_shot('DISPLAY_SM_USER_DATA','NULL')
        Wait_delay(1000)
        Log_msg('changing state to test_state3')
        Change_state('test_sm','test_state3')
        Halt_column()
     End_column()




     Start_queue_column("test_sm_test_state3_chain",false,"test_sm_test_state3_queue")
        Log_msg('test_state3 starting')
        Set_sm_user_data('test_sm','(void *)state3_data')
        One_shot('DISPLAY_SM_USER_DATA','NULL')
        Wait_delay(1000)
        Log_msg('changing state to test_state1')
        Change_state('test_sm','test_state1')
        Halt_column()
     End_column()
























--[[
pass_c([[
#include "test_state_machine.h"
#include "Cfl_user_functions.h"
#include "test_interface_functions.h"


static void test_state_machine_a(Handle_config_CFL_t* config_handle);
static void test_state_machine_b(Handle_config_CFL_t* config_handle);
static void test_state_machine_c(Handle_config_CFL_t* config_handle);
static void test_state_machine_d(Handle_config_CFL_t* config_handle);

void test_state_machine(void) {





  Handle_config_CFL_t* config_handle = Create_config_handle_CFL(debug_write);

  Printf_CFL("column control test\n");
  

  config_handle->number_of_columns = 30;
  config_handle->number_of_column_elements = 300;

  config_handle->number_column_functions = 100;
  config_handle->number_bool_functions = 50;
  config_handle->number_if_functions = 50;
  config_handle->one_shot_functions = 50;
  config_handle->number_of_try_functions = 50;
  config_handle->number_of_state_machines = 10;
  config_handle->number_of_named_queues = 50;


  



  //test_state_machine_a(config_handle);
 // test_state_machine_b(config_handle);
 // test_state_machine_c(config_handle);
  test_state_machine_d(config_handle);
  free(config_handle);
}

static const char *test_data = "test_data for test_state_machine_a";
static const char *state1_data = "state1_data for test_state_machine_a";
static const char *state2_data = "state2_data for test_state_machine_a";
static const char *state3_data = "state3_data for test_state_machine_a";

static void display_sm_user_data(void *input, void *params,Event_data_CFL_t *event_data) {
     Printf_CFL("display_sm_user_data: %s\n", (char*)Sms_get_user_data_CFL(input,0));
}



reset_sm_environment()
Start_function('test_state_machine_a')
Conf_engine('config_handle','200000','2500')

Store_one_shot("DISPLAY_SM_USER_DATA", 'display_sm_user_data')
start_column_names = {'start_column'}
Def_columns('start_column_names',start_column_names)

dofile("test_state_a.inc")

Start_column('start_column',true)
  Log_msg('start column')
  Dump_state_machines()
  Enable_sms_list("sm_array_name1",{"test_sm"})
  One_shot("DISPLAY_SM_USER_DATA",'NULL')
  Dump_state_machines()
  Wait_delay(10000)
  Disable_sms_list("sm_array_name2",{"test_sm"})
  Wait_delay(5000)
  Enable_sms_list("sm_array_name3",{"test_sm"})
  Wait_delay(10000)
  Log_msg("terminating engine")
  Stop_engine() 
End_column() -- No active columns engine will terminate
Start_engine( 100, 30, 'default_idle_function', 'default_calendar_function')
Destroy_engine('done with test_state_machine')

--  -----------------------------------------------------------------------
reset_sm_environment()
Start_function('test_state_machine_b')
Conf_engine('config_handle','200000','2500')

Store_one_shot("DISPLAY_SM_USER_DATA", 'display_sm_user_data')
start_column_names = {'start_column'}
Def_columns('start_column_names',start_column_names)

dofile("test_state_a.inc")

Start_column('start_column',true)
  Log_msg('start column')
  
  Enable_disable_sms("sm_array_name1",{"test_sm"}) -- terminate  sm if column  is disabled
  Wait_delay(10000)
  Term_column() --  
End_column() -- No active columns engine will terminate
Start_engine( 100, 30, 'default_idle_function', 'default_calendar_function')
Destroy_engine('done with test_state_machine')


pass_c([[

static bool event_generator_fn(void *input, void *params,Event_data_CFL_t *event_data) {
  While_column_control_CFL_t *while_control = (While_column_control_CFL_t *)params;
  if (while_control->current_iterations >= 300){
    return false;
  } 
  return true;
  
  
}
static const char *sm_event_data = "test_data for test_state_machine_c";

static void display_event_fn(void *input, void *params,Event_data_CFL_t *event_data) {
  process_event_t_CFL *process_event =(process_event_t_CFL *)params;
  char *message = (char *)process_event->user_data;
  if( message != NULL){
    Printf_CFL("message: %s  event index %d\n", message,event_data->event_index);
  }else{
  Printf_CFL("display_event_fn: %d\n", event_data->event_index);
  }
}





reset_sm_environment()
Start_function('test_state_machine_c')
Conf_engine('config_handle','200000','2500')
Store_boolean_fn('event_generator','event_generator_fn')
Store_one_shot("display_event",'display_event_fn')
Generate_event("sm_event",47,56.,'(void *)sm_event_data')
start_column_names = {'start_column','while_event_column'}
Def_columns('start_column_names',start_column_names)

dofile("test_state_b.inc")

Start_column('start_column',true)
  Log_msg('start column')
 
  Enable_disable_sms("sm_array_name1",{"test_sm"})
  While_columns('event_generator','while_column_array',{'while_event_column'},'NULL')
  Term_column() --  
End_column() -- No active columns engine will terminate

Start_column('while_event_column',false)
  Wait_delay(1000)
  Send_state_machine_event("test_sm", '&sm_event')
  
  Term_column() 
End_column() 


Start_engine( 100, 30, 'default_idle_function', 'default_calendar_function')
Destroy_engine('done with test_state_machine')

pass_c(([[
static const char *sm_event_data_1 = "test_data_1 for test_state_machine_c";
static const char *sm_event_data_2 = "test_data_2 for test_state_machine_c";
static const char *sm_event_data_3 = "test_data_3 for test_state_machine_c";
static const char *test_data_1 = "test_data for test_state_machine_a";
static const char *test_data_2 = "test_data for test_state_machine_a";
static const char *test_data_a = "top level state machine manager";
static const char *test_data_ba = "sub state manager  ";
static const char *test_data_b = "sub state state 1";
static const char *test_data_c = "sub state state 2";
static const char *test_data_d = "sub state state 3";


reset_sm_environment()
Start_function('test_state_machine_d')
Conf_engine('config_handle','200000','2500')
Store_boolean_fn('event_generator','event_generator_fn')
Store_one_shot("display_event",'display_event_fn')
Generate_event("sm_event_1",47,56.,'(void *)sm_event_data_1')
Generate_event("sm_event_2",48,57.,'(void *)sm_event_data_2')
Generate_event("sm_event_3",49,58.,'(void *)sm_event_data_3')
start_column_names = {'start_column','while_event_column'}
Def_columns('start_column_names',start_column_names)

dofile("test_state_c.inc")

Start_column('start_column',true)
  Log_msg('start column')
 
  Enable_disable_sms("sm_array_name1",{"test_sm"})
  Wait_delay(200) -- wait for state machine to start
  While_columns('event_generator','while_column_array',{'while_event_column'},'NULL')
  Term_column() --  
End_column() -- No active columns engine will terminate

Start_column('while_event_column',false)
  Wait_delay(200)
  --Wait_delay(200)
  Send_state_machine_event("test_sm", '&sm_event_1')
  --Wait_delay(200)
  Send_state_machine_event("test_sm", '&sm_event_2')
  --Wait_delay(200)
  Send_state_machine_event("test_sm", '&sm_event_3')
 
  Term_column() 
End_column() 


Start_engine( 100, 30, 'default_idle_function', 'default_calendar_function')
Destroy_engine('done with test_state_machine')





]]